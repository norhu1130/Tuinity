From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sat, 18 May 2019 12:25:19 -0700
Subject: [PATCH] Util patch


diff --git a/src/main/java/com/tuinity/tuinity/chunk/SingleThreadChunkRegionManager.java b/src/main/java/com/tuinity/tuinity/chunk/SingleThreadChunkRegionManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..b8f5aafc8a9cb75364adf26c2d653fa17d4046fc
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/chunk/SingleThreadChunkRegionManager.java
@@ -0,0 +1,405 @@
+package com.tuinity.tuinity.chunk;
+
+import co.aikar.timings.MinecraftTimings;
+import co.aikar.timings.Timing;
+import com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.WorldServer;
+import java.util.ArrayList;
+import java.util.EnumMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.function.Function;
+import java.util.function.LongFunction;
+
+public final class SingleThreadChunkRegionManager<T extends Enum<T> & SingleThreadChunkRegionManager.RegionDataCreator<T>> {
+
+    static final int REGION_SECTION_MERGE_RADIUS = 1;
+    // if this becomes > 8, then the RegionSection needs to be properly modified (see bitset)
+    public static final int REGION_CHUNK_SIZE = 8;
+    public static final int REGION_CHUNK_SIZE_SHIFT = 3; // log2(REGION_CHUNK_SIZE)
+
+    public final WorldServer world;
+    public final Class<T> dataClass;
+    public final String name;
+
+    public final Timing addChunkTimings;
+    public final Timing removeChunkTimings;
+    public final Timing regionRecalculateTimings;
+
+    protected final Long2ObjectOpenHashMap<RegionSection<T>> regionsBySection = new Long2ObjectOpenHashMap<>();
+    protected final ReferenceLinkedOpenHashSet<Region<T>> needsRecalculation = new ReferenceLinkedOpenHashSet<>();
+    protected final int minSectionRecalcCount;
+    protected final double maxDeadRegionPercent;
+
+    public SingleThreadChunkRegionManager(final WorldServer world, final Class<T> enumClass,
+                                          final int minSectionRecalcCount, final double maxDeadRegionPercent,
+                                          final String name) {
+        this.world = world;
+        this.dataClass = enumClass;
+        this.name = name;
+        this.minSectionRecalcCount = Math.max(2, minSectionRecalcCount);
+        this.maxDeadRegionPercent = maxDeadRegionPercent;
+
+        String prefix = world.getWorld().getName() + " - Region Manager - " + name + " - ";
+        this.addChunkTimings = MinecraftTimings.getInternalTaskName(prefix.concat("add"));
+        this.removeChunkTimings = MinecraftTimings.getInternalTaskName(prefix.concat("remove"));
+        this.regionRecalculateTimings = MinecraftTimings.getInternalTaskName(prefix.concat("recalculate"));
+    }
+
+    protected void addToRecalcQueue(final Region<T> region) {
+        this.needsRecalculation.add(region);
+    }
+
+    protected void removeFromRecalcQueue(final Region<T> region) {
+        this.needsRecalculation.remove(region);
+    }
+
+    public RegionSection<T> getRegionSection(final int chunkX, final int chunkZ) {
+        return this.regionsBySection.get(MCUtil.getCoordinateKey(chunkX >> REGION_CHUNK_SIZE_SHIFT, chunkZ >> REGION_CHUNK_SIZE_SHIFT));
+    }
+
+    public Region<T> getRegion(final int chunkX, final int chunkZ) {
+        final RegionSection<T> section = this.regionsBySection.get(MCUtil.getCoordinateKey(chunkX >> REGION_CHUNK_SIZE_SHIFT, chunkZ >> REGION_CHUNK_SIZE_SHIFT));
+        return section != null ? section.region : null;
+    }
+
+    private final List<Region<T>> toMerge = new ArrayList<>((2 * REGION_SECTION_MERGE_RADIUS + 1) * (2 * REGION_SECTION_MERGE_RADIUS + 1));
+    protected final LongFunction<RegionSection<T>> createRegionIfAbsent = (final long keyInMap) -> {
+        return new RegionSection<>(keyInMap, SingleThreadChunkRegionManager.this);
+    };
+
+    protected RegionSection<T> getOrCreateAndMergeSection(final int sectionX, final int sectionZ, final RegionSection<T> force) {
+        // find optimal candidate to merge into
+        final int minX = sectionX - REGION_SECTION_MERGE_RADIUS;
+        final int maxX = sectionX + REGION_SECTION_MERGE_RADIUS;
+        final int minZ = sectionZ - REGION_SECTION_MERGE_RADIUS;
+        final int maxZ = sectionZ + REGION_SECTION_MERGE_RADIUS;
+
+        int mergeCandidateSectionSize = -1;
+        Region<T> mergeIntoCandidate = null;
+
+        for (int currX = minX; currX <= maxX; ++currX) {
+            for (int currZ = minZ; currZ <= maxZ; ++currZ) {
+                final RegionSection<T> section = this.regionsBySection.get(MCUtil.getCoordinateKey(currX, currZ));
+                if (section == null) {
+                    continue;
+                }
+                final Region<T> region = section.region;
+                if (region.dead) {
+                    throw new IllegalStateException("Dead region should not be in live region manager state: " + region);
+                }
+                final int sections = region.sections.size();
+
+                if (sections > mergeCandidateSectionSize) {
+                    mergeCandidateSectionSize = sections;
+                    mergeIntoCandidate = region;
+                }
+                this.toMerge.add(region);
+            }
+        }
+
+        // merge
+        if (mergeIntoCandidate != null) {
+            for (int len = this.toMerge.size(), i = len - 1; i >= 0; --i) {
+                final Region<T> region = this.toMerge.remove(i);
+                if (region.dead || mergeIntoCandidate == region) {
+                    continue;
+                }
+                region.mergeInto(mergeIntoCandidate);
+            }
+        } else {
+            mergeIntoCandidate = new Region<>(this);
+        }
+
+        final long sectionKey = MCUtil.getCoordinateKey(sectionX, sectionZ);
+        final RegionSection<T> section;
+        if (force == null) {
+            section = this.regionsBySection.computeIfAbsent(sectionKey, this.createRegionIfAbsent);
+        } else {
+            final RegionSection<T> existing = this.regionsBySection.putIfAbsent(sectionKey, force);
+            if (existing != null) {
+                throw new IllegalStateException("Attempting to override section '" + existing.toStringWithRegion() +
+                        ", with " + force.toStringWithRegion());
+            }
+
+            section = force;
+        }
+
+        section.region = mergeIntoCandidate;
+        mergeIntoCandidate.sections.add(section);
+
+        return section;
+    }
+
+    public void addChunk(final int chunkX, final int chunkZ) {
+        this.addChunkTimings.startTiming();
+        try {
+            this.getOrCreateAndMergeSection(chunkX >> REGION_CHUNK_SIZE_SHIFT, chunkZ >> REGION_CHUNK_SIZE_SHIFT, null).addChunk(chunkX, chunkZ);
+        } finally {
+            this.addChunkTimings.stopTiming();
+        }
+    }
+
+    public void removeChunk(final int chunkX, final int chunkZ) {
+        this.removeChunkTimings.startTiming();
+        try {
+            final RegionSection<T> section = this.regionsBySection.get(
+                    MCUtil.getCoordinateKey(chunkX >> REGION_CHUNK_SIZE_SHIFT, chunkZ >> REGION_CHUNK_SIZE_SHIFT));
+            if (section != null) {
+                section.removeChunk(chunkX, chunkZ);
+            } else {
+                throw new IllegalStateException("Cannot remove chunk at (" + chunkX + "," + chunkZ + ") from region state, section does not exist");
+            }
+        } finally {
+            this.removeChunkTimings.stopTiming();
+        }
+    }
+
+    public void recalculateRegions() {
+        for (int i = 0, len = this.needsRecalculation.size(); i < len; ++i) {
+            final Region<T> region = this.needsRecalculation.removeFirst();
+
+            this.recalculateRegion(region);
+        }
+    }
+
+    protected void recalculateRegion(final Region<T> region) {
+        this.regionRecalculateTimings.startTiming();
+        try {
+            region.markedForRecalc = false;
+            // clear unused regions
+            for (final Iterator<RegionSection<T>> iterator = region.deadSections.iterator(); iterator.hasNext(); ) {
+                final RegionSection<T> deadSection = iterator.next();
+                if (!this.regionsBySection.remove(deadSection.regionCoordinate, deadSection)) {
+                    throw new IllegalStateException("Cannot remove dead section '" +
+                            deadSection.toStringWithRegion() + "' from section state! State at section coordinate: " +
+                            this.regionsBySection.get(deadSection.regionCoordinate));
+                }
+                if (!region.sections.remove(deadSection)) {
+                    throw new IllegalStateException("Region " + region + " has inconsistent state, it should contain section " + deadSection);
+                }
+
+                iterator.remove();
+            }
+
+            // implicitly cover cases where size == 0
+            if (region.sections.size() < this.minSectionRecalcCount) {
+                return;
+            }
+
+            // run a test to see if we actually need to recalculate
+            // TODO
+
+            // destroy and rebuild the region
+            region.dead = true;
+
+            // destroy region state
+            for (final Iterator<RegionSection<T>> iterator = region.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+                final RegionSection<T> aliveSection = iterator.next();
+                if (!this.regionsBySection.remove(aliveSection.regionCoordinate, aliveSection)) {
+                    throw new IllegalStateException("Cannot remove alive section '" +
+                            aliveSection.toStringWithRegion() + "' from section state! State at section coordinate: " +
+                            this.regionsBySection.get(aliveSection.regionCoordinate));
+                }
+            }
+
+            // rebuild regions
+            for (final Iterator<RegionSection<T>> iterator = region.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+                final RegionSection<T> aliveSection = iterator.next();
+                this.getOrCreateAndMergeSection(aliveSection.getSectionX(), aliveSection.getSectionZ(), aliveSection);
+            }
+        } finally {
+            this.regionRecalculateTimings.stopTiming();
+        }
+    }
+
+    public static final class Region<T extends Enum<T> & SingleThreadChunkRegionManager.RegionDataCreator<T>> {
+        protected final IteratorSafeOrderedReferenceSet<RegionSection<T>> sections = new IteratorSafeOrderedReferenceSet<>(true);
+        protected final ReferenceOpenHashSet<RegionSection<T>> deadSections = new ReferenceOpenHashSet<>(16, 0.7f);
+        protected boolean dead;
+        protected boolean markedForRecalc;
+
+        public final SingleThreadChunkRegionManager<T> regionManager;
+
+        protected Region(final SingleThreadChunkRegionManager<T> regionManager) {
+            this.regionManager = regionManager;
+        }
+
+        public IteratorSafeOrderedReferenceSet.Iterator<RegionSection<T>> getSections() {
+            return this.sections.iterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS);
+        }
+
+        protected final double getDeadSectionPercent() {
+            return (double)this.deadSections.size() / (double)this.sections.size();
+        }
+
+        protected void mergeInto(final Region<T> mergeTarget) {
+            if (this.dead) {
+                throw new IllegalStateException("Source region is dead! Source " + this + ", target " + mergeTarget);
+            } else if (mergeTarget.dead) {
+                throw new IllegalStateException("Target region is dead! Source " + this + ", target " + mergeTarget);
+            }
+            this.dead = true;
+
+            for (final Iterator<RegionSection<T>> iterator = this.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+                final RegionSection<T> section = iterator.next();
+
+                if (!mergeTarget.sections.add(section)) {
+                    throw new IllegalStateException("Target cannot contain source's sections! Source " + this + ", target " + mergeTarget);
+                }
+
+                section.region = mergeTarget;
+            }
+
+            for (final RegionSection<T> deadSection : this.deadSections) {
+                if (!this.sections.contains(deadSection)) {
+                    throw new IllegalStateException("Source region does not even contain its own dead sections! Missing " + deadSection + " from region " + this);
+                }
+                mergeTarget.deadSections.add(deadSection);
+            }
+        }
+
+        protected void markSectionAlive(final RegionSection<T> section) {
+            this.deadSections.remove(section);
+            if (this.markedForRecalc && (this.sections.size() < this.regionManager.minSectionRecalcCount || this.getDeadSectionPercent() < this.regionManager.maxDeadRegionPercent)) {
+                this.regionManager.removeFromRecalcQueue(this);
+                this.markedForRecalc = false;
+            }
+        }
+
+        protected void markSectionDead(final RegionSection<T> section) {
+            this.deadSections.add(section);
+            if (!this.markedForRecalc && (this.sections.size() >= this.regionManager.minSectionRecalcCount || this.sections.size() == this.deadSections.size()) && this.getDeadSectionPercent() >= this.regionManager.maxDeadRegionPercent) {
+                this.regionManager.addToRecalcQueue(this);
+                this.markedForRecalc = true;
+            }
+        }
+
+        @Override
+        public String toString() {
+            final StringBuilder ret = new StringBuilder(128);
+
+            ret.append("Region{");
+            ret.append("dead=").append(this.dead).append(',');
+            ret.append("markedForRecalc=").append(this.markedForRecalc).append(',');
+
+            ret.append("sectionCount=").append(this.sections.size()).append(',');
+            ret.append("sections=[");
+            for (final Iterator<RegionSection<T>> iterator = this.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+                final RegionSection<T> section = iterator.next();
+                ret.append(section);
+                if (iterator.hasNext()) {
+                    ret.append(',');
+                }
+            }
+            ret.append(']');
+
+            ret.append('}');
+            return ret.toString();
+        }
+    }
+
+    public static final class RegionSection<T extends Enum<T> & SingleThreadChunkRegionManager.RegionDataCreator<T>> {
+        protected final long regionCoordinate;
+        protected long chunksBitset;
+        protected Region<T> region;
+        protected final EnumMap<T, Object> data;
+        protected final Function<? super T, Object> createIfAbsentFunction;
+
+        public final SingleThreadChunkRegionManager<T> regionManager;
+
+        protected RegionSection(final long regionCoordinate, final SingleThreadChunkRegionManager<T> regionManager) {
+            this.regionCoordinate = regionCoordinate;
+            this.data = new EnumMap<>(regionManager.dataClass);
+            this.regionManager = regionManager;
+            this.createIfAbsentFunction = (final T keyInMap) -> {
+                return keyInMap.createData(RegionSection.this, regionManager);
+            };
+        }
+
+        public int getSectionX() {
+            return MCUtil.getCoordinateX(this.regionCoordinate);
+        }
+
+        public int getSectionZ() {
+            return MCUtil.getCoordinateZ(this.regionCoordinate);
+        }
+
+        public Region<T> getRegion() {
+            return this.region;
+        }
+
+        public Object getData(final T key) {
+            return this.data.get(key);
+        }
+
+        public Object getOrCreateData(final T key) {
+            return this.data.computeIfAbsent(key, this.createIfAbsentFunction);
+        }
+
+        public Object removeData(final T key) {
+            return this.data.remove(key);
+        }
+
+        public void setData(final T key, final Object data) {
+            this.data.put(key, data);
+        }
+
+        private static int getChunkIndex(final int chunkX, final int chunkZ) {
+            return (chunkX & (REGION_CHUNK_SIZE - 1)) | ((chunkZ & (REGION_CHUNK_SIZE - 1)) << REGION_CHUNK_SIZE_SHIFT);
+        }
+
+        protected void addChunk(final int chunkX, final int chunkZ) {
+            final long bitset = this.chunksBitset;
+            final long after = this.chunksBitset = bitset | (1L << getChunkIndex(chunkX, chunkZ));
+            if (after == bitset) {
+                throw new IllegalStateException("Cannot add a chunk to a section which already has the chunk! RegionSection: " + this + ", global chunk: " + new ChunkCoordIntPair(chunkX, chunkZ).toString());
+            }
+            if (bitset != 0L) {
+                return;
+            }
+            this.region.markSectionAlive(this);
+        }
+
+        protected void removeChunk(final int chunkX, final int chunkZ) {
+            final long before = this.chunksBitset;
+            final long bitset = this.chunksBitset = before & ~(1L << getChunkIndex(chunkX, chunkZ));
+            if (before == bitset) {
+                throw new IllegalStateException("Cannot remove a chunk from a section which does not have that chunk! RegionSection: " + this + ", global chunk: " + new ChunkCoordIntPair(chunkX, chunkZ).toString());
+            }
+            if (bitset != 0L) {
+                return;
+            }
+            this.region.markSectionDead(this);
+        }
+
+        @Override
+        public String toString() {
+            return "RegionSection{" +
+                    "regionCoordinate=" + new ChunkCoordIntPair(this.regionCoordinate).toString() + "," +
+                    "chunksBitset=" + Long.toHexString(this.chunksBitset) + "," +
+                    "hash=" + this.hashCode() + "," +
+                    "}";
+        }
+
+        public String toStringWithRegion() {
+            return "RegionSection{" +
+                    "regionCoordinate=" + new ChunkCoordIntPair(this.regionCoordinate).toString() + "," +
+                    "chunksBitset=" + Long.toHexString(this.chunksBitset) + "," +
+                    "hash=" + this.hashCode() + "," +
+                    "region=" + this.region + "," +
+                    "}";
+        }
+    }
+
+    public static interface RegionDataCreator<E extends Enum<E> & RegionDataCreator<E>> {
+
+        Object createData(final RegionSection<E> section,
+                          final SingleThreadChunkRegionManager<E> regionManager);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/tuinity/tuinity/util/IntervalledCounter.java b/src/main/java/com/tuinity/tuinity/util/IntervalledCounter.java
new file mode 100644
index 0000000000000000000000000000000000000000..d2c7d2c7920324d7207225ed19484e804368489d
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/IntervalledCounter.java
@@ -0,0 +1,100 @@
+package com.tuinity.tuinity.util;
+
+public final class IntervalledCounter {
+
+    protected long[] times;
+    protected final long interval;
+    protected long minTime;
+    protected int sum;
+    protected int head; // inclusive
+    protected int tail; // exclusive
+
+    public IntervalledCounter(final long interval) {
+        this.times = new long[8];
+        this.interval = interval;
+    }
+
+    public void updateCurrentTime() {
+        this.updateCurrentTime(System.nanoTime());
+    }
+
+    public void updateCurrentTime(final long currentTime) {
+        int sum = this.sum;
+        int head = this.head;
+        final int tail = this.tail;
+        final long minTime = currentTime - this.interval;
+
+        final int arrayLen = this.times.length;
+
+        // guard against overflow by using subtraction
+        while (head != tail && this.times[head] - minTime < 0) {
+            head = (head + 1) % arrayLen;
+            --sum;
+        }
+
+        this.sum = sum;
+        this.head = head;
+        this.minTime = minTime;
+    }
+
+    public void addTime(final long currTime) {
+        // guard against overflow by using subtraction
+        if (currTime - this.minTime < 0) {
+            return;
+        }
+        int nextTail = (this.tail + 1) % this.times.length;
+        if (nextTail == this.head) {
+            this.resize();
+            nextTail = (this.tail + 1) % this.times.length;
+        }
+
+        this.times[this.tail] = currTime;
+        this.tail = nextTail;
+    }
+
+    public void updateAndAdd(final int count) {
+        final long currTime = System.nanoTime();
+        this.updateCurrentTime(currTime);
+        for (int i = 0; i < count; ++i) {
+            this.addTime(currTime);
+        }
+    }
+
+    public void updateAndAdd(final int count, final long currTime) {
+        this.updateCurrentTime(currTime);
+        for (int i = 0; i < count; ++i) {
+            this.addTime(currTime);
+        }
+    }
+
+    private void resize() {
+        final long[] oldElements = this.times;
+        final long[] newElements = new long[this.times.length * 2];
+        this.times = newElements;
+
+        final int head = this.head;
+        final int tail = this.tail;
+        final int size = tail >= head ? (tail - head) : (tail + (oldElements.length - head));
+        this.head = 0;
+        this.tail = size;
+
+        if (tail >= head) {
+            System.arraycopy(oldElements, head, newElements, 0, size);
+        } else {
+            System.arraycopy(oldElements, head, newElements, 0, oldElements.length - head);
+            System.arraycopy(oldElements, 0, newElements, oldElements.length - head, tail);
+        }
+    }
+
+    // returns in units per second
+    public double getRate() {
+        return this.size() / (this.interval * 1.0e-9);
+    }
+
+    public int size() {
+        final int head = this.head;
+        final int tail = this.tail;
+
+        return tail >= head ? (tail - head) : (tail + (this.times.length - head));
+    }
+}
diff --git a/src/main/java/com/tuinity/tuinity/util/maplist/IteratorSafeOrderedReferenceSet.java b/src/main/java/com/tuinity/tuinity/util/maplist/IteratorSafeOrderedReferenceSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..6d2851ffa32e299dc7588e29ad5076253786080e
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/maplist/IteratorSafeOrderedReferenceSet.java
@@ -0,0 +1,288 @@
+package com.tuinity.tuinity.util.maplist;
+
+import it.unimi.dsi.fastutil.objects.Reference2IntLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Reference2IntMap;
+import org.bukkit.Bukkit;
+import java.util.Arrays;
+import java.util.NoSuchElementException;
+
+public final class IteratorSafeOrderedReferenceSet<E> {
+
+    public static final int ITERATOR_FLAG_SEE_ADDITIONS = 1 << 0;
+
+    protected final Reference2IntLinkedOpenHashMap<E> indexMap;
+    protected int firstInvalidIndex = -1;
+
+    /* list impl */
+    protected E[] listElements;
+    protected int listSize;
+
+    protected final double maxFragFactor;
+
+    protected int iteratorCount;
+
+    private final boolean threadRestricted;
+
+    public IteratorSafeOrderedReferenceSet() {
+        this(16, 0.75f, 16, 0.2);
+    }
+
+    public IteratorSafeOrderedReferenceSet(final boolean threadRestricted) {
+        this(16, 0.75f, 16, 0.2, threadRestricted);
+    }
+
+    public IteratorSafeOrderedReferenceSet(final int setCapacity, final float setLoadFactor, final int arrayCapacity,
+                                           final double maxFragFactor) {
+        this(setCapacity, setLoadFactor, arrayCapacity, maxFragFactor, false);
+    }
+    public IteratorSafeOrderedReferenceSet(final int setCapacity, final float setLoadFactor, final int arrayCapacity,
+                                           final double maxFragFactor, final boolean threadRestricted) {
+        this.indexMap = new Reference2IntLinkedOpenHashMap<>(setCapacity, setLoadFactor);
+        this.indexMap.defaultReturnValue(-1);
+        this.maxFragFactor = maxFragFactor;
+        this.listElements = (E[])new Object[arrayCapacity];
+        this.threadRestricted = threadRestricted;
+    }
+
+    protected final boolean allowSafeIteration() {
+        return !this.threadRestricted || Bukkit.isPrimaryThread();
+    }
+
+    protected final double getFragFactor() {
+        return 1.0 - ((double)this.indexMap.size() / (double)this.listSize);
+    }
+
+    public int createRawIterator() {
+        if (this.allowSafeIteration()) {
+            ++this.iteratorCount;
+        }
+        if (this.indexMap.isEmpty()) {
+            return -1;
+        } else {
+            return this.firstInvalidIndex == 0 ? this.indexMap.getInt(this.indexMap.firstKey()) : 0;
+        }
+    }
+
+    public int advanceRawIterator(final int index) {
+        final E[] elements = this.listElements;
+        int ret = index + 1;
+        for (int len = this.listSize; ret < len; ++ret) {
+            if (elements[ret] != null) {
+                return ret;
+            }
+        }
+
+        return -1;
+    }
+
+    public void finishRawIterator() {
+        if (this.allowSafeIteration() && --this.iteratorCount == 0) {
+            if (this.getFragFactor() >= this.maxFragFactor) {
+                this.defrag();
+            }
+        }
+    }
+
+    public boolean remove(final E element) {
+        final int index = this.indexMap.removeInt(element);
+        if (index >= 0) {
+            if (this.firstInvalidIndex < 0 || index < this.firstInvalidIndex) {
+                this.firstInvalidIndex = index;
+            }
+            if (this.listElements[index] != element) {
+                throw new IllegalStateException();
+            }
+            this.listElements[index] = null;
+            if (this.allowSafeIteration() && this.iteratorCount == 0 && this.getFragFactor() >= this.maxFragFactor) {
+                this.defrag();
+            }
+            return true;
+        }
+        return false;
+    }
+
+    public boolean contains(final E element) {
+        return this.indexMap.containsKey(element);
+    }
+
+    public boolean add(final E element) {
+        final int listSize = this.listSize;
+
+        final int previous = this.indexMap.putIfAbsent(element, listSize);
+        if (previous != -1) {
+            return false;
+        }
+
+        if (listSize >= this.listElements.length) {
+            this.listElements = Arrays.copyOf(this.listElements, listSize * 2);
+        }
+        this.listElements[listSize] = element;
+        this.listSize = listSize + 1;
+
+        return true;
+    }
+
+    protected void defrag() {
+        if (this.firstInvalidIndex < 0) {
+            return; // nothing to do
+        }
+
+        if (this.indexMap.isEmpty()) {
+            Arrays.fill(this.listElements, 0, this.listSize, null);
+            this.listSize = 0;
+            this.firstInvalidIndex = -1;
+            return;
+        }
+
+        final E[] backingArray = this.listElements;
+
+        int lastValidIndex;
+        java.util.Iterator<Reference2IntMap.Entry<E>> iterator;
+
+        if (this.firstInvalidIndex == 0) {
+            iterator = this.indexMap.reference2IntEntrySet().fastIterator();
+            lastValidIndex = 0;
+        } else {
+            lastValidIndex = this.firstInvalidIndex;
+            final E key = backingArray[lastValidIndex - 1];
+            iterator = this.indexMap.reference2IntEntrySet().fastIterator(new Reference2IntMap.Entry<E>() {
+                @Override
+                public int getIntValue() {
+                    throw new UnsupportedOperationException();
+                }
+
+                @Override
+                public int setValue(int i) {
+                    throw new UnsupportedOperationException();
+                }
+
+                @Override
+                public E getKey() {
+                    return key;
+                }
+            });
+        }
+
+        while (iterator.hasNext()) {
+            final Reference2IntMap.Entry<E> entry = iterator.next();
+
+            final int newIndex = lastValidIndex++;
+            backingArray[newIndex] = entry.getKey();
+            entry.setValue(newIndex);
+        }
+
+        // cleanup end
+        Arrays.fill(backingArray, lastValidIndex, this.listSize, null);
+        this.listSize = lastValidIndex;
+        this.firstInvalidIndex = -1;
+    }
+
+    public E rawGet(final int index) {
+        return this.listElements[index];
+    }
+
+    public int size() {
+        // always returns the correct amount - listSize can be different
+        return this.indexMap.size();
+    }
+
+    public IteratorSafeOrderedReferenceSet.Iterator<E> iterator() {
+        return this.iterator(0);
+    }
+
+    public IteratorSafeOrderedReferenceSet.Iterator<E> iterator(final int flags) {
+        if (this.allowSafeIteration()) {
+            ++this.iteratorCount;
+        }
+        return new BaseIterator<>(this, true, (flags & ITERATOR_FLAG_SEE_ADDITIONS) != 0 ? Integer.MAX_VALUE : this.listSize);
+    }
+
+    public java.util.Iterator<E> unsafeIterator() {
+        return this.unsafeIterator(0);
+    }
+    public java.util.Iterator<E> unsafeIterator(final int flags) {
+        return new BaseIterator<>(this, false, (flags & ITERATOR_FLAG_SEE_ADDITIONS) != 0 ? Integer.MAX_VALUE : this.listSize);
+    }
+
+    public static interface Iterator<E> extends java.util.Iterator<E> {
+
+        public void finishedIterating();
+
+    }
+
+    protected static final class BaseIterator<E> implements IteratorSafeOrderedReferenceSet.Iterator<E> {
+
+        protected final IteratorSafeOrderedReferenceSet<E> set;
+        protected final boolean canFinish;
+        protected final int maxIndex;
+        protected int nextIndex;
+        protected E pendingValue;
+        protected boolean finished;
+        protected E lastReturned;
+
+        protected BaseIterator(final IteratorSafeOrderedReferenceSet<E> set, final boolean canFinish, final int maxIndex) {
+            this.set = set;
+            this.canFinish = canFinish;
+            this.maxIndex = maxIndex;
+        }
+
+        @Override
+        public boolean hasNext() {
+            if (this.finished) {
+                return false;
+            }
+            if (this.pendingValue != null) {
+                return true;
+            }
+
+            final E[] elements = this.set.listElements;
+            int index, len;
+            for (index = this.nextIndex, len = Math.min(this.maxIndex, this.set.listSize); index < len; ++index) {
+                final E element = elements[index];
+                if (element != null) {
+                    this.pendingValue = element;
+                    this.nextIndex = index + 1;
+                    return true;
+                }
+            }
+
+            this.nextIndex = index;
+            return false;
+        }
+
+        @Override
+        public E next() {
+            if (!this.hasNext()) {
+                throw new NoSuchElementException();
+            }
+            final E ret = this.pendingValue;
+
+            this.pendingValue = null;
+            this.lastReturned = ret;
+
+            return ret;
+        }
+
+        @Override
+        public void remove() {
+            final E lastReturned = this.lastReturned;
+            if (lastReturned == null) {
+                throw new IllegalStateException();
+            }
+            this.lastReturned = null;
+            this.set.remove(lastReturned);
+        }
+
+        @Override
+        public void finishedIterating() {
+            if (this.finished || !this.canFinish) {
+                throw new IllegalStateException();
+            }
+            this.lastReturned = null;
+            this.finished = true;
+            if (this.set.allowSafeIteration()) {
+                this.set.finishRawIterator();
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockBase.java b/src/main/java/net/minecraft/server/BlockBase.java
index 1f334d63282bd5c23dc3b275a220f09e60c34537..85f60b56b5689b77ba3d9e99e29b4f734df5d91e 100644
--- a/src/main/java/net/minecraft/server/BlockBase.java
+++ b/src/main/java/net/minecraft/server/BlockBase.java
@@ -295,14 +295,14 @@ public abstract class BlockBase {
 
     public abstract static class BlockData extends IBlockDataHolder<Block, IBlockData> {
 
-        private final int b;
-        private final boolean e;
+        private final int b; public final int getEmittedLight() { return this.b; } // Tuinity - OBFHELPER
+        private final boolean e; public final boolean isTransparentOnSomeFaces() { return this.e; } // Tuinity - OBFHELPER
         private final boolean f;
         private final Material g;
         private final MaterialMapColor h;
         public final float strength;
         private final boolean j;
-        private final boolean k;
+        private final boolean k; public final boolean isOpaque() { return this.k; } // Tuinity - OBFHELPER
         private final BlockBase.e l;
         private final BlockBase.e m;
         private final BlockBase.e n;
@@ -343,12 +343,20 @@ public abstract class BlockBase {
         protected Fluid fluid;
         // Paper end
 
+        // Tuinity start - micro the hell out of this call
+        protected boolean shapeExceedsCube = true;
+        public final boolean shapeExceedsCube() {
+            return this.shapeExceedsCube;
+        }
+        // Tuinity end
+
         public void a() {
             this.fluid = this.getBlock().d(this.p()); // Paper - moved from getFluid()
             this.isTicking = this.getBlock().isTicking(this.p()); // Paper - moved from isTicking()
             if (!this.getBlock().o()) {
                 this.a = new BlockBase.BlockData.Cache(this.p());
             }
+            this.shapeExceedsCube = this.a == null || this.a.c; // Tuinity - moved from actual method to here
 
         }
 
@@ -372,10 +380,12 @@ public abstract class BlockBase {
             return this.a != null ? this.a.g : this.getBlock().b(this.p(), iblockaccess, blockposition);
         }
 
+        public final int getOpacity(IBlockAccess iblockaccess, BlockPosition blockposition) { return this.b(iblockaccess, blockposition); } // Tuinity - OBFHELPER
         public int b(IBlockAccess iblockaccess, BlockPosition blockposition) {
             return this.a != null ? this.a.h : this.getBlock().f(this.p(), iblockaccess, blockposition);
         }
 
+        public final VoxelShape getCullingFace(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) { return this.a(iblockaccess, blockposition, enumdirection); } // Tuinity - OBFHELPER
         public VoxelShape a(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
             return this.a != null && this.a.i != null ? this.a.i[enumdirection.ordinal()] : VoxelShapes.a(this.c(iblockaccess, blockposition), enumdirection);
         }
@@ -385,7 +395,7 @@ public abstract class BlockBase {
         }
 
         public final boolean d() { // Paper
-            return this.a == null || this.a.c;
+            return this.shapeExceedsCube; // Tuinity - moved into shape cache init
         }
 
         public final boolean e() { // Paper
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 6acb5f05a05c542f8257e205ef70987be2d29194..b1a166365053c4096f082d8a53de05d38bde8159 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -121,7 +121,7 @@ public class ChunkProviderServer extends IChunkProvider {
         return (Chunk)this.getChunkAt(x, z, ChunkStatus.FULL, true);
     }
 
-    private long chunkFutureAwaitCounter;
+    long chunkFutureAwaitCounter; // Tuinity - private -> package private
 
     public void getEntityTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
         if (Thread.currentThread() != this.serverThread) {
@@ -210,6 +210,165 @@ public class ChunkProviderServer extends IChunkProvider {
     }
     // Paper end - rewrite ticklistserver
 
+    // Tuinity start
+    // this will try to avoid chunk neighbours for lighting
+    public final IChunkAccess getFullStatusChunkAt(int chunkX, int chunkZ) {
+        Chunk ifLoaded = this.getChunkAtIfLoadedImmediately(chunkX, chunkZ);
+        if (ifLoaded != null) {
+            return ifLoaded;
+        }
+
+        IChunkAccess empty = this.getChunkAt(chunkX, chunkZ, ChunkStatus.EMPTY, true);
+        if (empty != null && empty.getChunkStatus() == ChunkStatus.FULL) {
+            return empty;
+        }
+        return this.getChunkAt(chunkX, chunkZ, ChunkStatus.FULL, true);
+    }
+
+    public final IChunkAccess getFullStatusChunkAtIfLoaded(int chunkX, int chunkZ) {
+        Chunk ifLoaded = this.getChunkAtIfLoadedImmediately(chunkX, chunkZ);
+        if (ifLoaded != null) {
+            return ifLoaded;
+        }
+
+        IChunkAccess ret = this.getChunkAtImmediately(chunkX, chunkZ);
+        if (ret != null && ret.getChunkStatus() == ChunkStatus.FULL) {
+            return ret;
+        } else {
+            return null;
+        }
+    }
+
+    void getChunkAtAsynchronously(int chunkX, int chunkZ, int ticketLevel,
+                                  java.util.function.Consumer<IChunkAccess> consumer) {
+        this.getChunkAtAsynchronously(chunkX, chunkZ, ticketLevel, (PlayerChunk playerChunk) -> {
+            if (ticketLevel <= 33) {
+                return (CompletableFuture)playerChunk.getFullChunkFuture();
+            } else {
+                return playerChunk.getOrCreateFuture(PlayerChunk.getChunkStatus(ticketLevel), ChunkProviderServer.this.playerChunkMap);
+            }
+        }, consumer);
+    }
+
+    void getChunkAtAsynchronously(int chunkX, int chunkZ, int ticketLevel,
+                                  java.util.function.Function<PlayerChunk, CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>> function,
+                                  java.util.function.Consumer<IChunkAccess> consumer) {
+        if (Thread.currentThread() != this.serverThread) {
+            throw new IllegalStateException();
+        }
+        ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(chunkX, chunkZ);
+        Long identifier = Long.valueOf(this.chunkFutureAwaitCounter++);
+        this.addTicketAtLevel(TicketType.FUTURE_AWAIT, chunkPos, ticketLevel, identifier);
+        this.tickDistanceManager();
+
+        PlayerChunk chunk = this.playerChunkMap.getUpdatingChunk(chunkPos.pair());
+
+        if (chunk == null) {
+            throw new IllegalStateException("Expected playerchunk " + chunkPos + " in world '" + this.world.getWorld().getName() + "'");
+        }
+
+        CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> future = function.apply(chunk);
+
+        future.whenCompleteAsync((either, throwable) -> {
+            try {
+                if (throwable != null) {
+                    if (throwable instanceof ThreadDeath) {
+                        throw (ThreadDeath)throwable;
+                    }
+                    MinecraftServer.LOGGER.fatal("Failed to complete future await for chunk " + chunkPos.toString() + " in world '" + ChunkProviderServer.this.world.getWorld().getName() + "'", throwable);
+                } else if (either.right().isPresent()) {
+                    MinecraftServer.LOGGER.fatal("Failed to complete future await for chunk " + chunkPos.toString() + " in world '" + ChunkProviderServer.this.world.getWorld().getName() + "': " + either.right().get().toString());
+                }
+
+                try {
+                    if (consumer != null) {
+                        consumer.accept(either == null ? null : either.left().orElse(null)); // indicate failure to the callback.
+                    }
+                } catch (Throwable thr) {
+                    if (thr instanceof ThreadDeath) {
+                        throw (ThreadDeath)thr;
+                    }
+                    MinecraftServer.LOGGER.fatal("Load callback for future await failed " + chunkPos.toString() + " in world '" + ChunkProviderServer.this.world.getWorld().getName() + "'", thr);
+                    return;
+                }
+            } finally {
+                // due to odd behaviour with CB unload implementation we need to have these AFTER the load callback.
+                ChunkProviderServer.this.addTicketAtLevel(TicketType.UNKNOWN, chunkPos, ticketLevel, chunkPos);
+                ChunkProviderServer.this.removeTicketAtLevel(TicketType.FUTURE_AWAIT, chunkPos, ticketLevel, identifier);
+            }
+        }, this.serverThreadQueue);
+    }
+
+    void chunkLoadAccept(int chunkX, int chunkZ, IChunkAccess chunk, java.util.function.Consumer<IChunkAccess> consumer) {
+        try {
+            consumer.accept(chunk);
+        } catch (Throwable throwable) {
+            if (throwable instanceof ThreadDeath) {
+                throw (ThreadDeath)throwable;
+            }
+            MinecraftServer.LOGGER.error("Load callback for chunk " + chunkX + "," + chunkZ + " in world '" + this.world.getWorld().getName() + "' threw an exception", throwable);
+        }
+    }
+
+    public final void getChunkAtAsynchronously(int chunkX, int chunkZ, ChunkStatus status, boolean gen, boolean allowSubTicketLevel, java.util.function.Consumer<IChunkAccess> onLoad) {
+        // try to fire sync
+        int chunkStatusTicketLevel = 33 + ChunkStatus.getTicketLevelOffset(status);
+        PlayerChunk playerChunk = this.playerChunkMap.getUpdatingChunk(MCUtil.getCoordinateKey(chunkX, chunkZ));
+        if (playerChunk != null) {
+            ChunkStatus holderStatus = playerChunk.getChunkHolderStatus();
+            IChunkAccess immediate = playerChunk.getAvailableChunkNow();
+            if (immediate != null) {
+                if (allowSubTicketLevel ? immediate.getChunkStatus().isAtLeastStatus(status) : (playerChunk.getTicketLevel() <= chunkStatusTicketLevel && holderStatus != null && holderStatus.isAtLeastStatus(status))) {
+                    this.chunkLoadAccept(chunkX, chunkZ, immediate, onLoad);
+                    return;
+                } else {
+                    if (gen || (!allowSubTicketLevel && immediate.getChunkStatus().isAtLeastStatus(status))) {
+                        this.getChunkAtAsynchronously(chunkX, chunkZ, chunkStatusTicketLevel, onLoad);
+                        return;
+                    } else {
+                        this.chunkLoadAccept(chunkX, chunkZ, null, onLoad);
+                        return;
+                    }
+                }
+            }
+        }
+
+        // need to fire async
+
+        if (gen && !allowSubTicketLevel) {
+            this.getChunkAtAsynchronously(chunkX, chunkZ, chunkStatusTicketLevel, onLoad);
+            return;
+        }
+
+        this.getChunkAtAsynchronously(chunkX, chunkZ, MCUtil.getTicketLevelFor(ChunkStatus.EMPTY), (IChunkAccess chunk) -> {
+            if (chunk == null) {
+                throw new IllegalStateException("Chunk cannot be null");
+            }
+
+            if (!chunk.getChunkStatus().isAtLeastStatus(status)) {
+                if (gen) {
+                    this.getChunkAtAsynchronously(chunkX, chunkZ, chunkStatusTicketLevel, onLoad);
+                    return;
+                } else {
+                    ChunkProviderServer.this.chunkLoadAccept(chunkX, chunkZ, null, onLoad);
+                    return;
+                }
+            } else {
+                if (allowSubTicketLevel) {
+                    ChunkProviderServer.this.chunkLoadAccept(chunkX, chunkZ, chunk, onLoad);
+                    return;
+                } else {
+                    this.getChunkAtAsynchronously(chunkX, chunkZ, chunkStatusTicketLevel, onLoad);
+                    return;
+                }
+            }
+        });
+    }
+
+    final com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<Chunk> tickingChunks = new com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
+    final com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<Chunk> entityTickingChunks = new com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
+    // Tuinity end
+
     public ChunkProviderServer(WorldServer worldserver, Convertable.ConversionSession convertable_conversionsession, DataFixer datafixer, DefinedStructureManager definedstructuremanager, Executor executor, ChunkGenerator chunkgenerator, int i, boolean flag, WorldLoadListener worldloadlistener, Supplier<WorldPersistentData> supplier) {
         this.world = worldserver;
         this.serverThreadQueue = new ChunkProviderServer.a(worldserver);
@@ -600,8 +759,8 @@ public class ChunkProviderServer extends IChunkProvider {
         return !this.a(playerchunk, k);
     }
 
-    @Override
-    public IBlockAccess c(int i, int j) {
+    public final IBlockAccess getFeaturesReadyChunk(int x, int z) { return this.c(x, z); } // Tuinity - OBFHELPER
+    @Override public IBlockAccess c(int i, int j) { // Tuinity - OBFHELPER
         long k = ChunkCoordIntPair.pair(i, j);
         PlayerChunk playerchunk = this.getChunk(k);
 
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index d9021fde3d0908dc89384617055874ac356a8fcf..4fc96ef8c6062d94fb58aa274e9050235dcb1b9b 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -207,6 +207,14 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
     }
     // CraftBukkit end
 
+    // Tuinity start
+    public final AxisAlignedBB getBoundingBoxAt(double x, double y, double z) {
+        double widthHalf = (double)this.size.width / 2.0;
+        double height = (double)this.size.height;
+        return new AxisAlignedBB(x - widthHalf, y, z - widthHalf, x + widthHalf, y + height, z + widthHalf);
+    }
+    // Tuinity end
+
     // Paper start - optimise entity tracking
     final org.spigotmc.TrackingRange.TrackingRangeType trackingRangeType = org.spigotmc.TrackingRange.getTrackingRangeType(this);
 
diff --git a/src/main/java/net/minecraft/server/HeightMap.java b/src/main/java/net/minecraft/server/HeightMap.java
index 14ddb2a8949ce18a0c42e17a82d0d7a13ac325fe..476da43b9f0ef35b4985f88e4784b1f8c5222af3 100644
--- a/src/main/java/net/minecraft/server/HeightMap.java
+++ b/src/main/java/net/minecraft/server/HeightMap.java
@@ -101,6 +101,7 @@ public class HeightMap {
         }
     }
 
+    public final int get(int x, int z) { return this.a(x, z); } // Tuinity - OBFHELPER
     public int a(int i, int j) {
         return this.a(c(i, j));
     }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index a2f59133429632f886d5c5ff7bb2b4672d39ccf3..a3a93da4fbc2fe91c520ebb85b939e24f1091fa8 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -156,6 +156,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
     public org.bukkit.command.RemoteConsoleCommandSender remoteConsole;
     //public ConsoleReader reader; // Paper
     public static int currentTick = 0; // Paper - Further improve tick loop
+    public static long currentTickLong = 0L; // Tuinity
     public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
     public int autosavePeriod;
     public boolean serverAutoSave = false; // Paper
@@ -969,6 +970,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
                         this.lastOverloadTime = this.nextTick;
                     }
 
+                    ++MinecraftServer.currentTickLong; // Tuinity
                     if ( ++MinecraftServer.currentTick % SAMPLE_INTERVAL == 0 )
                     {
                         final long diff = curTime - tickSection;
@@ -1354,6 +1356,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
                 midTickLoadChunks(); // Paper
                 worldserver.timings.doTick.startTiming(); // Spigot
                 worldserver.doTick(booleansupplier);
+                worldserver.getChunkProvider().playerChunkMap.dataRegionManager.recalculateRegions(); // Tuinity
                 worldserver.timings.doTick.stopTiming(); // Spigot
                 midTickLoadChunks(); // Paper
             } catch (Throwable throwable) {
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 11a67ca18f566bfc214659e7fb454ea2b4d8a7ad..ffa16930ade0fee788706955f340e03b09ec52cb 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -504,6 +504,7 @@ public class PlayerChunk {
         // Paper end - per player view distance
     }
 
+    public final CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> getOrCreateFuture(ChunkStatus chunkstatus, PlayerChunkMap playerchunkmap) { return this.a(chunkstatus, playerchunkmap); } // Tuinity - OBFHELPER
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> a(ChunkStatus chunkstatus, PlayerChunkMap playerchunkmap) {
         int i = chunkstatus.c();
         CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> completablefuture = (CompletableFuture) this.statusFutures.get(i);
@@ -674,6 +675,9 @@ public class PlayerChunk {
                     // Paper start - rewrite ticklistserver
                     PlayerChunk.this.chunkMap.world.onChunkSetTicking(PlayerChunk.this.location.x, PlayerChunk.this.location.z);
                     // Paper end - rewrite ticklistserver
+                    // Tuinity start - ticking chunk set
+                    PlayerChunk.this.chunkMap.world.getChunkProvider().tickingChunks.add(tickingChunk);
+                    // Tuinity end - ticking chunk set
 
                 }
             });
@@ -684,6 +688,12 @@ public class PlayerChunk {
         if (flag4 && !flag5) {
             this.tickingFuture.complete(PlayerChunk.UNLOADED_CHUNK); this.isTickingReady = false; // Paper - cache chunk ticking stage
             this.tickingFuture = PlayerChunk.UNLOADED_CHUNK_FUTURE;
+            // Tuinity start - ticking chunk set
+            Chunk chunkIfCached = this.getFullChunkIfCached();
+            if (chunkIfCached != null) {
+                this.chunkMap.world.getChunkProvider().tickingChunks.remove(chunkIfCached);
+            }
+            // Tuinity end - ticking chunk set
         }
 
         boolean flag6 = playerchunk_state.isAtLeast(PlayerChunk.State.ENTITY_TICKING);
@@ -701,7 +711,9 @@ public class PlayerChunk {
                     Chunk entityTickingChunk = either.left().get();
                     PlayerChunk.this.isEntityTickingReady = true;
 
-
+                    // Tuinity start - entity ticking chunk set
+                    PlayerChunk.this.chunkMap.world.getChunkProvider().entityTickingChunks.add(entityTickingChunk);
+                    // Tuinity end - entity ticking chunk set
 
 
                 }
@@ -713,6 +725,12 @@ public class PlayerChunk {
         if (flag6 && !flag7) {
             this.entityTickingFuture.complete(PlayerChunk.UNLOADED_CHUNK); this.isEntityTickingReady = false; // Paper - cache chunk ticking stage
             this.entityTickingFuture = PlayerChunk.UNLOADED_CHUNK_FUTURE;
+            // Tuinity start - entity ticking chunk set
+            Chunk chunkIfCached = this.getFullChunkIfCached();
+            if (chunkIfCached != null) {
+                this.chunkMap.world.getChunkProvider().entityTickingChunks.remove(chunkIfCached);
+            }
+            // Tuinity end - entity ticking chunk set
         }
 
         // Paper start - raise IO/load priority if priority changes, use our preferred priority
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 6c399bcea03e839bf2f21e92b5d76d46b7088667..126ea76096375708e1b79dc497c89172371cdf51 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -277,6 +277,21 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
     // Paper end
 
+    // Tuinity start
+    public static enum RegionData implements com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager.RegionDataCreator<RegionData> {
+
+        ;
+
+        @Override
+        public Object createData(com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager.RegionSection<RegionData> section,
+                                 com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager<RegionData> regionManager) {
+            throw new AbstractMethodError();
+        }
+    }
+
+    public final com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager<RegionData> dataRegionManager;
+    // Tuiniy end
+
     private final java.util.concurrent.ExecutorService lightThread;
     public PlayerChunkMap(WorldServer worldserver, Convertable.ConversionSession convertable_conversionsession, DataFixer datafixer, DefinedStructureManager definedstructuremanager, Executor executor, IAsyncTaskHandler<Runnable> iasynctaskhandler, ILightAccess ilightaccess, ChunkGenerator chunkgenerator, WorldLoadListener worldloadlistener, Supplier<WorldPersistentData> supplier, int i, boolean flag) {
         super(new File(convertable_conversionsession.a(worldserver.getDimensionKey()), "region"), datafixer, flag);
@@ -444,6 +459,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), null, true, false); // unloaded, loaded
             });
         // Paper end - no-tick view distance
+        // Tuinity start
+        this.dataRegionManager = new com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager<>(this.world, RegionData.class, 2, (1.0 / 3.0), "Data");
+        // Tuinity end
     }
     // Paper start - Chunk Prioritization
     public void queueHolderUpdate(PlayerChunk playerchunk) {
@@ -778,6 +796,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     playerchunk.a(j);
                 } else {
                     playerchunk = new PlayerChunk(new ChunkCoordIntPair(i), j, this.lightEngine, this.p, this);
+                    this.dataRegionManager.addChunk(playerchunk.location.x, playerchunk.location.z); // Tuinity
                 }
 
                 this.updatingChunks.put(i, playerchunk);
@@ -1020,7 +1039,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             if (completablefuture1 != completablefuture) {
                 this.a(i, playerchunk);
             } else {
-                if (this.pendingUnload.remove(i, playerchunk) && ichunkaccess != null) {
+                // Tuinity start
+                boolean removed;
+                if ((removed = this.pendingUnload.remove(i, playerchunk)) && ichunkaccess != null) { // Tuinity end
                     if (ichunkaccess instanceof Chunk) {
                         ((Chunk) ichunkaccess).setLoaded(false);
                     }
@@ -1044,6 +1065,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     this.lightEngine.queueUpdate();
                     this.worldLoadListener.a(ichunkaccess.getPos(), (ChunkStatus) null);
                 }
+                if (removed) this.dataRegionManager.removeChunk(playerchunk.location.x, playerchunk.location.z); // Tuinity
 
             }
         };
@@ -1710,6 +1732,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         return chunkHolder == null ? null : chunkHolder.getAvailableChunkNow();
     }
     // Paper end
+    // Tuinity start
+    public PlayerChunk getUnloadingPlayerChunk(int chunkX, int chunkZ) {
+        return this.pendingUnload.get(ChunkCoordIntPair.pair(chunkX, chunkZ));
+    }
+    // Tuinity end
 
 
     // Paper start - async io
diff --git a/src/main/java/net/minecraft/server/VoxelShapes.java b/src/main/java/net/minecraft/server/VoxelShapes.java
index e21c747b6c39155c44bf30860681d67b0b29fb12..9f4f9df09968dc45878ad59f5ee45672a3f08fbd 100644
--- a/src/main/java/net/minecraft/server/VoxelShapes.java
+++ b/src/main/java/net/minecraft/server/VoxelShapes.java
@@ -314,6 +314,7 @@ public final class VoxelShapes {
         }
     }
 
+    public static boolean combinationOccludes(VoxelShape voxelshape, VoxelShape voxelshape1) { return b(voxelshape, voxelshape1); } // Tuinity - OBFHELPER
     public static boolean b(VoxelShape voxelshape, VoxelShape voxelshape1) {
         return voxelshape != b() && voxelshape1 != b() ? (voxelshape.isEmpty() && voxelshape1.isEmpty() ? false : !c(b(), b(voxelshape, voxelshape1, OperatorBoolean.OR), OperatorBoolean.ONLY_FIRST)) : true;
     }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 5b0b6edfa790918e56399ff6c83f3feb6e5aca49..f291877532d61c0d7ae1d7125cfd5d0ab08bc2a8 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -55,6 +55,7 @@ import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
+import it.unimi.dsi.fastutil.ints.IntArrayList; // Tuinity
 
 public class WorldServer extends World implements GeneratorAccessSeed {
 
@@ -205,6 +206,96 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     }
     // Paper end - rewrite ticklistserver
 
+    // Tuinity start
+    public final boolean areChunksLoadedForMove(AxisAlignedBB axisalignedbb) {
+        // copied code from collision methods, so that we can guarantee that they wont load chunks (we don't override
+        // ICollisionAccess methods for VoxelShapes)
+        // be more strict too, add a block (dumb plugins in move events?)
+        int minBlockX = MathHelper.floor(axisalignedbb.minX - 1.0E-7D) - 3;
+        int maxBlockX = MathHelper.floor(axisalignedbb.maxX + 1.0E-7D) + 3;
+
+        int minBlockZ = MathHelper.floor(axisalignedbb.minZ - 1.0E-7D) - 3;
+        int maxBlockZ = MathHelper.floor(axisalignedbb.maxZ + 1.0E-7D) + 3;
+
+        int minChunkX = minBlockX >> 4;
+        int maxChunkX = maxBlockX >> 4;
+
+        int minChunkZ = minBlockZ >> 4;
+        int maxChunkZ = maxBlockZ >> 4;
+
+        ChunkProviderServer chunkProvider = this.getChunkProvider();
+
+        for (int cx = minChunkX; cx <= maxChunkX; ++cx) {
+            for (int cz = minChunkZ; cz <= maxChunkZ; ++cz) {
+                if (chunkProvider.getChunkAtIfLoadedImmediately(cx, cz) == null) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    public final void loadChunksForMoveAsync(AxisAlignedBB axisalignedbb, double toX, double toZ,
+                                             java.util.function.Consumer<List<IChunkAccess>> onLoad) {
+        if (Thread.currentThread() != this.serverThread) {
+            this.getChunkProvider().serverThreadQueue.execute(() -> {
+                this.loadChunksForMoveAsync(axisalignedbb, toX, toZ, onLoad);
+            });
+            return;
+        }
+        List<IChunkAccess> ret = new java.util.ArrayList<>();
+        IntArrayList ticketLevels = new IntArrayList();
+
+        int minBlockX = MathHelper.floor(axisalignedbb.minX - 1.0E-7D) - 3;
+        int maxBlockX = MathHelper.floor(axisalignedbb.maxX + 1.0E-7D) + 3;
+
+        int minBlockZ = MathHelper.floor(axisalignedbb.minZ - 1.0E-7D) - 3;
+        int maxBlockZ = MathHelper.floor(axisalignedbb.maxZ + 1.0E-7D) + 3;
+
+        int minChunkX = minBlockX >> 4;
+        int maxChunkX = maxBlockX >> 4;
+
+        int minChunkZ = minBlockZ >> 4;
+        int maxChunkZ = maxBlockZ >> 4;
+
+        ChunkProviderServer chunkProvider = this.getChunkProvider();
+
+        int requiredChunks = (maxChunkX - minChunkX + 1) * (maxChunkZ - minChunkZ + 1);
+        int[] loadedChunks = new int[1];
+
+        Long holderIdentifier = Long.valueOf(chunkProvider.chunkFutureAwaitCounter++);
+
+        java.util.function.Consumer<IChunkAccess> consumer = (IChunkAccess chunk) -> {
+            if (chunk != null) {
+                int ticketLevel = Math.max(33, chunkProvider.playerChunkMap.getUpdatingChunk(chunk.getPos().pair()).getTicketLevel());
+                ret.add(chunk);
+                ticketLevels.add(ticketLevel);
+                chunkProvider.addTicketAtLevel(TicketType.FUTURE_AWAIT, chunk.getPos(), ticketLevel, holderIdentifier);
+            }
+            if (++loadedChunks[0] == requiredChunks) {
+                try {
+                    onLoad.accept(java.util.Collections.unmodifiableList(ret));
+                } finally {
+                    for (int i = 0, len = ret.size(); i < len; ++i) {
+                        ChunkCoordIntPair chunkPos = ret.get(i).getPos();
+                        int ticketLevel = ticketLevels.getInt(i);
+
+                        chunkProvider.addTicketAtLevel(TicketType.UNKNOWN, chunkPos, ticketLevel, chunkPos);
+                        chunkProvider.removeTicketAtLevel(TicketType.FUTURE_AWAIT, chunkPos, ticketLevel, holderIdentifier);
+                    }
+                }
+            }
+        };
+
+        for (int cx = minChunkX; cx <= maxChunkX; ++cx) {
+            for (int cz = minChunkZ; cz <= maxChunkZ; ++cz) {
+                chunkProvider.getChunkAtAsynchronously(cx, cz, ChunkStatus.FULL, true, false, consumer);
+            }
+        }
+    }
+    // Tuinity end
+
     // Add env and gen to constructor, WorldData -> WorldDataServer
     public WorldServer(MinecraftServer minecraftserver, Executor executor, Convertable.ConversionSession convertable_conversionsession, IWorldDataServer iworlddataserver, ResourceKey<World> resourcekey, DimensionManager dimensionmanager, WorldLoadListener worldloadlistener, ChunkGenerator chunkgenerator, boolean flag, long i, List<MobSpawner> list, boolean flag1, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen) {
         super(iworlddataserver, resourcekey, dimensionmanager, minecraftserver::getMethodProfiler, false, flag, i, gen, env, executor); // Paper pass executor
